<!DOCTYPE html>
<html>
<head>
  <title>hotpotato's project page</title>
  <link href="css/stylesheet.css" rel="stylesheet" type="text/css" media="screen" />
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-16430253-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script');
      ga.type = 'text/javascript';
      ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(ga, s);
    })();

  </script>
</head>
<body>
<div id="container">
  <div id="projects">
    hotpotato |
  <a href="http://efflux.biasedbit.com/">efflux</a> |
  <a href="http://windroplr.com/">windroplr</a>
  </div>
  <h1>hotpotato's project page</h1>
  <h2 class="subtitle">a high performance Java HTTP client for servers</h2>

  <div id="lastupdate">21/10/2010</div>
  <h2><a name="about"></a>What is hotpotato?</h2>
  <p>
    <span class="hotpotato">hotpotato</span> - or hptt, from the common misspelling of http - is a Java high
    performance and throughput oriented HTTP client library, <strong>with support for HTTP 1.1 pipelining</strong>.
    It was developed mostly towards server-side usage, where speed and low resource usage are the key factors,
    but can be used to build client applications as well.
  </p>

  <h3>Built for speed</h3>
  <p>
    Built on top of <a href="http://www.jboss.org/netty">Netty</a> and designed for high concurrency scenarios where
    multiple threads can use the same instance of a client without any worries for external or internal synchronization,
    <span class="hotpotato">hotpotato</span> helps you reduce initialization and/or preparation times and resource
    squandering. Among many small optimizations, connections are reused <strong>whenever possible</strong>, which
    results in a severe reduction of total request execution times by cutting connection establishment overhead.
  </p>
  <h3>Simple and familiar API</h3>
  <p>
    The API is extremely simple and, for anyone already familiar with Netty, comprehension will be simple.
  </p>
  <p>
    The semantics of <code>execute()</code> (<code>HttpClient</code> interface) may look somewhat awkward but remember
    this library was built with server-side usage in mind, where often you end up repeating the requests to the same
    4/5 hosts (if that many...).
  </p>
  <p>
    For a more typical HTTP client API (to the likes of Apache HttpClient or similar libs), you should check the
    package <code>com.biasedbit.hotpotato.session</code>, which hides the "server-side'ness" of
    <span class="hotpotato">hotpotato</span>. Among other things, this API offers automatic handling of redirections,
    digest/basic auth, cookies, while allowing you to feed unparsed URL's (e.g. 'http://hotpotato.biasedbit.com/uri') as
    target for your requests.
  </p>

  <h4>Note:</h4>
  <p>
    Until this software hits version 1.0, it's considered to be in BETA stage.<br />
    I encourage you to look & hack the code to your needs. Comments, improvements, patches, rants and praises are all
    welcome at <a href="#links">the mailing list</a>.
  </p>
  <p>
    If you want a full-featured library to use mostly on the client side, check out
    <a href="http://github.com/AsyncHttpClient/async-http-client">this great project</a> by
    <a href="http://twitter.com/jfarcand">@jfarcand</a>.
  </p>
  <p>
    It has a lot more features and doesn't expose Netty's classes directly. It even has a JDK based implementation
    for the network layer!
  </p>

  <hr />
  <h2><a name="repository"></a>Repository</h2>

  <p>
    The project is currently hosted at <a href="http://github.com/brunodecarvalho/hotpotato">GitHub</a>.
  </p>

  <hr />
  <h2><a name="releases"></a>Releases</h2>

  <h3>Version 0.8.0</h3>
  <ul>
    <li><a href="http://github.com/downloads/brunodecarvalho/hotpotato/hotpotato-0.8.0.jar">Binaries</a></li>
    <li><a href="http://github.com/downloads/brunodecarvalho/hotpotato/hotpotato-0.8.0-sources.jar">Sources (jar)</a></li>
    <li><a href="http://github.com/downloads/brunodecarvalho/hotpotato/hotpotato-0.8.0-dist.zip">Full package (zip)</a></li>
    <li><a href="http://github.com/downloads/brunodecarvalho/hotpotato/hotpotato-0.8.0-dist.tar.bz2">Full package (tar.bz2)</a></li>
  </ul>

  <hr />
  <h2><a name="documentation"></a>Documentation</h2>

  <h3>Version 0.8.0</h3>
  <ul>
    <li><a href="doc/0.8.0/userguide/html/">User guide (HTML)*</a></li>
    <li><a href="doc/0.8.0/userguide/html_single/">User guide (HTML, single page)*</a></li>
    <li><a href="doc/0.8.0/userguide/pdf/hotpotato-userguide.pdf">User guide (PDF)*</a></li>
    <li><a href="doc/0.8.0/api/">API (Javadoc)</a></li>
    <li><a href="doc/0.8.0/xref/">Source code (XREF)</a></li>
  </ul>

  <h4>Note:</h4>
  <p>
    This documentation is still a work in progress. Chapter 2 is full of placeholders at this
    time. I'll keep updating the user guide, but you shouldn't expect a <em>full</em> document before version 1.0.
  </p>
  <p>
    Items marked with * have been generated using docbook and JBoss's maven-jdocbook-plugin. The templates for the PDF
    were left untouched but the CSS for the HTML versions were slightly modified, hence the resemblance with JBoss's
    community documentation.
  </p>

  <hr />
  <h2>Performance</h2>
  <p>Coming really soon...</p>

  <hr />
  <h2><a name="roadmap"></a>Roadmap</h2>
  <ul>
    <li><span class="text">
      Implement serious SSL support (currently relies on Netty's example classes)
    </span></li>
    <li><span class="text">
      Your idea here...
    </span></li>
  </ul>

  <hr />
  <h2><a name="license"></a>License</h2>
  <p>
    <span class="hotpotato">hotpotato</span> is distributed under Apache License, Version 2.0.
    Please see the enclosed NOTICE.txt, COPYRIGHT.txt, and LICENSE.txt for more information.
  </p>

  <hr />
  <h2><a name="links"></a>Mailing list & other useful stuff</h2>
  <h3>Mailing list</h3>
  <p>
    The project's mailing list is
    <a href="http://groups.google.com/group/hotpotato-users">hotpotato-users@googlegroups.com</a>. At the moment there
    is no need for multiple lists so all discussions (dev, announcements, help, ranting) go in there.
  </p>
  <p>
    It requires a google account, which you can create by clicking the link.
  </p>

  <h3>Dependencies</h3>
  <p>
    <span class="hotpotato">hotpotato</span> needs only <a href="http://www.jboss.org/netty">Netty</a> 3.2 (Final)
    and JDK 1.6.
  </p>

  <h3>Useless links</h3>
  <ul>
    <li><a href="http://twitter.com/brunodecarvalho">follow @brunodecarvalho at twitter</a></li>
    <li><a href="http://bruno.biasedbit.com/blag">the blag</a></li>
  </ul>

  <hr />
  <h2><a name="examples"></a>Examples</h2>
  <p>
    The following are quick & dirty examples whose sole purpose is to give you an idea of how
    <span class="hotpotato">hotpotato</span> is used. Please refer to <a href="#documentation">documentation</a>
    section.
  </p>
  <h3>Synchronous mode</h3>
  <p>
    When executing requests in synchronous mode, the calling thread will block (much like Apache's HttpClient).
  </p>
  <pre>
// Create & initialise the client
HttpClient client = new DefaultHttpClient();
client.init();

// Setup the request
HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_0,
                                             HttpMethod.GET, "/");

// Execute the request, turning the result into a String
HttpRequestFuture future = client.execute("hotpotato.biasedbit.com", 80, request,
                                          new BodyAsStringProcessor());
future.awaitUninterruptibly();
// Print some details about the request
System.out.println(future);

// If response was >= 200 and <= 299, print the body
if (future.isSuccessfulResponse()) {
    System.out.println(future.getProcessedResult());
}

// Cleanup
client.terminate();
  </pre>
  <h3>Asynchronous mode</h3>
  <p>
    In asynchronous mode, the calling thread will proceed immediately after submitting the request. If any computation
    needs to be done when the request is terminated, a listener should be added to the object returned when submitting
    requests.
  </p>
  <pre>
// Execute the request
HttpRequestFuture&lt;String&gt; future = client.execute("hotpotato.biasedbit.com", 80, request,
                                                  new BodyAsStringProcessor());
future.addListener(new HttpRequestFutureListener&lt;String&gt;() {
    @Override
    public void operationComplete(HttpRequestFuture&lt;String&gt; future) throws Exception {
        System.out.println(future);
        if (future.isSuccessfulResponse()) {
            System.out.println(future.getProcessedResult());
        }
        client.terminate();
    }
});
  </pre>
  <p>
    Using the <strong>HttpClient API</strong> directly you may need to add extra headers manually.
    You'll also need to handle redirect codes and authentication manually.
  </p>
  <p>
    This is the API to use when you want absolute control over each and every request.
  </p>
  <pre>
request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,
                                 "/webhp?hl=pt-PT&tab=iw");
request.addHeader(HttpHeaders.Names.HOST, "www.google.pt");
future = client.execute("www.google.pt", 80, request, new BodyAsStringProcessor());
  </pre>
  <p>
    Using the <strong>HttpSession API</strong>, everything is simpler and the library handles redirects automatically.
    Proxy support is also included, as well as Digest/Basic auth and optionally Cookie storage!
  </p>
  <p>
    This is the API to use when you just want to get things done and avoid the hassles of repetitive tasks.
  </p>
  <pre>
DefaultHttpSession session = new DefaultHttpSession(httpClient);
// Setup a proxy
session.setProxy("41.190.16.17", 8080);
// And add cookie handling capabilities
session.addHandler(new CookieStoringResponseHandler());

session.execute("http://google.com", HttpVersion.HTTP_1_1, HttpMethod.GET,
                new BodyAsStringProcessor());
  </pre>
  <p>
    The following is a comprehensive example of request to three distinct servers.
  </p>
  <pre>
final DefaultHttpClient client = new DefaultHttpClient();
client.setRequestTimeoutInMillis(5000);
client.init();

final CountDownLatch latch = new CountDownLatch(3);

HttpRequest request;
HttpRequestFuture&lt;String&gt; future;

request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
request.addHeader(HttpHeaders.Names.HOST, "hotpotato.biasedbit.com");
future = client.execute("hotpotato.biasedbit.com", 80, request,
                        new BodyAsStringProcessor());
future.addListener(new HttpRequestFutureListener&lt;String&gt;() {
    @Override
    public void operationComplete(HttpRequestFuture&lt;String&gt; future) throws Exception {
        System.out.println("\nHotpotato request: " + future);
        if (future.isSuccess()) {
            System.out.println(future.getResponse());
        } else {
            System.out.println(future.getResponse());
            future.getCause().printStackTrace();
        }
        if (future.isSuccessfulResponse()) {
            System.out.println(future.getProcessedResult());
        }
        latch.countDown();
    }
});

request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,
                                 "http://www.google.pt/webhp?hl=pt-PT&tab=iw");
request.addHeader(HttpHeaders.Names.HOST, "www.google.pt");
future = client.execute("www.google.pt", 80, request, new BodyAsStringProcessor());
future.addListener(new HttpRequestFutureListener&lt;String&gt;() {
    @Override
    public void operationComplete(HttpRequestFuture&lt;String&gt; future) throws Exception {
        System.out.println("\nGoogle request: " + future);
        if (future.isSuccess()) {
            System.out.println(future.getResponse());
        } else {
            System.out.println(future.getResponse());
            future.getCause().printStackTrace();
        }
        if (future.isSuccessfulResponse()) {
            System.out.println(future.getProcessedResult());
        }
        latch.countDown();
    }
});

request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,
                                 "http://twitter.com/");
future = client.execute("twitter.com", 80, request, new BodyAsStringProcessor());
request.addHeader(HttpHeaders.Names.HOST, "twitter.com");
future.addListener(new HttpRequestFutureListener&lt;String&gt;() {
    @Override
    public void operationComplete(HttpRequestFuture&lt;String&gt; future) throws Exception {
        System.out.println("\nTwitter request: " + future);
        if (future.isSuccess()) {
            System.out.println(future.getResponse());
        } else {
            System.out.println(future.getResponse());
            future.getCause().printStackTrace();
        }
        if (future.isSuccessfulResponse()) {
            System.out.println(future.getProcessedResult());
        }
        latch.countDown();
    }
});

try {
    latch.await();
} catch (InterruptedException e) {
    e.printStackTrace();
}

client.terminate();
  </pre>

  <hr />
  <div id="footer">
    (c) 2010 <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>/<a href="http://biasedbit.com/">BiasedBit</a>
  </div>
</div>
</body>
</html>