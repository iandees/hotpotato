<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [
    <!ENTITY % CustomDTD SYSTEM "../custom.dtd">
    %CustomDTD;
    ]>
<chapter id="architecture">
  <title>Architecture</title>

  <sect1>
    <title><classname>DefaultHttpClient</classname> inside out</title>
    <note>
      <para>
        This section describes some concepts that will be valid for all implementations of &HttpClient; but will also
        focus on some details that, at this time, pertain only to the sole implementation of this interface,
        &DefaultHttpClient; - meaning that this behavior can change in a different special-purpose implementation.
      </para>
    </note>
    <sect2>
      <title>Handling execution requests</title>
      <para>
        &DefaultHttpClient; deals with concurrent requests using a
        <ulink url="http://en.wikipedia.org/wiki/Producer-consumer_problem">producer-consumer</ulink> approach. Whenever
        a thread calls <methodname>execute()</methodname>, this implementation will generate a context object that will
        associate the three elements necessary to each request:
      </para>
      <itemizedlist>
        <listitem>
          <para>&HttpRequest;: contains the HTTP request data</para>
        </listitem>
        <listitem>
          <para>&HttpResponseProcessor;: the handler of the HTTP response, in case one is received</para>
        </listitem>
        <listitem>
          <para>&HttpRequestFuture;: the future that will be unlocked once this request is completed</para>
        </listitem>
      </itemizedlist>
      <para>
        The aggregator of these elements is a &HttpRequestContext;. Once generated, this context is then fed to a
        <classname>BlockingQueue</classname>. This effectively makes every caller of <methodname>execute()</methodname>
        a producer.
      </para>
      <!-- image here -->
      <para>
        On the other side of the <classname>BlockingQueue</classname> lies an internal event processing thread. The job
        of this thread is to process multiple types of events, generated at the left and right of &HttpClient;:
        <itemizedlist>
          <listitem>
            <para>
              <code>EXECUTE_REQUEST</code>: generated when producers submit new requests. Handling this event does not
              mean that the request will immediately be executed.
            </para>
          </listitem>
          <listitem>
            <para>
              <code>REQUEST_COMPLETE</code>: generated by &HttpConnection;s when a request completes.
            </para>
          </listitem>
          <listitem>
            <para>
              <code>CONNECTION_OPEN</code>: generated by the &HttpConnection;s, to signal a new connection is open and
              ready to perform requests.
            </para>
          </listitem>
          <listitem>
            <para>
              <code>CONNECTION_CLOSED</code>: generated by the &HttpConnection;s when a connection closes, either
              unexpectedly or gracefully (doesn't really matter for the &DefaultHttpClient;).
            </para>
          </listitem>
          <listitem>
            <para>
              <code>CONNECTION_FAILED</code>: generated by the &HttpConnection;s when a connection to a given host fails
              to establish.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
    <sect2>
      <title><classname>HttpRequestContext</classname> lifecycle</title>
      <!-- image -->
      <orderedlist>
        <listitem>
          <para>
            When a &HttpRequestContext; is created (when <methodname>execute()</methodname> is called on the
            &HttpClient;), it's wrapped in a <code>EXECUTE_REQUEST</code> event and put into the
            <classname>BlockingQueue</classname>.
          </para>
        </listitem>
        <listitem>
          <para>
            The event processor will pick this event and feed it to a &HostContext;. The &HostContext; contains, at
            every given moment, the number of connections open to that host, the number of connections opening and the
            requests queued for that host.
          </para>
          <para>
            Assuming this is the first request, no connection is open so the &HostContext; will signal back to the
            event processor that a new connection needs to be opened. At the same time it queues this request, but this
            time, it queues it on the specific &HostContext; it belongs to. All requests will eventuall pass from the
            event queue (wrapped in events, or &HttpClientEvent;) to the &HostContext; queue. This ensures that all
            request are executed in the exact same order they are submitted.
            <footnote>
              <para>
                Which doesn't necessarily mean that it will complete before another request, but that's a whole
                different story.
              </para>
            </footnote>
          </para>
        </listitem>
        <listitem>
          <para>
            When this connection finally opens - under the form of a &HttpConnection; - it fires up a
            <code>CONNECTION_OPEN</code> event. When the event processor handles this event it will then drain the
            &HostContext; queue into the recently open connection.
          </para>
        </listitem>
        <listitem>
          <para>
            Every time a <code>REQUEST_COMPLETE</code> is handled by the event processor, it will query the appropriate
            &HostContext; and drain any pending requests, one at a time, for each available &HttpConnection;.
            &HttpConnection;s are considered available when they are connected and not executing (sending and/or waiting
            for response) any requests.
          </para>
        </listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1>
    <title>Summary</title>
    <para>
      In this chapter we covered how &DefaultHttpClient; works internally and how it interacts both with the producers
      and the other components of &hotpotato;. This should provide you with a better understanding on why some of the
      configuration parameters affect &hotpotato;'s functioning they way they do.
    </para>
  </sect1>
</chapter>